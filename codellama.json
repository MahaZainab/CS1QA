[
    {
        "code": "from cs1robots import * load_world('worlds/harvest2.wld') hubo = Robot() hubo.set_trace('blue') def turn_right(): for i in range(3): hubo.turn_left() def gogo(): hubo.move() turn_right() hubo.move() hubo.turn_left() for i in range(6): hubo.move() turn_right() for i in range(3): turn_right() hubo.move() turn_right() hubo.move() for j in range(5): hubo.pick_beeper() gogo() hubo.pick_beeper() hubo.move() hubo.turn_left() hubo.move() hubo.turn_left() for k in range(5): hubo.pick_beeper() gogo() hubo.pick_beeper()",
        "question": "Please briefly explain the algorithm how you wrote it 5 times~",
        "questionType": "code_explain",
        "answer": "To pick up the ball\nWrite the process of picking up while going to the right with a for statement, and write the process of turning down and down the left again with a for statement.\nRepeated it 3 times"
    },
    {
        "code": "from cs1robots import* create_world() hubo=Robot() hubo.set_trace('blue') def turn_right(): hubo.turn_left() hubo.turn_left() hubo.turn_left() def go_straight(): for i in range(9): hubo.move() hubo.turn_left() for i in range(4): go_straight() turn_right() hubo.move() turn_right() go_straight() hubo.turn_left() hubo.move() hubo.turn_left() go_straight() turn_right() hubo.move() turn_right() go_straight()",
        "question": "Yes, in zigzag, Hubo is looking to the right at first, so I used hubo.turn_left(). Is it okay if the shape of the line at the beginning is different from the picture presented?",
        "questionType": "task",
        "answer": "Yes it's okay!"
    },
    {
        "code": "from math import * from cs1media import * #new_w,new_h = def foo(t, h): tan_val = tan(radians(t)) return tan_val * h def convert(input_img, t): black = (0, 0, 0) white = (255, 255, 255) new_img = None # Do not delete this line ### Your code ## width, height = input_img.size() final_img = create_picture(width, height, black) for y in range(height): for x in range(width): input_color = input_img.get(x, y) new_x = foo(-t, y) if 0 <= new_x < width: final_img.set(new_x + x, y, input_color) new_img = final_img ### End of your code ### return new_img #----------------------------------------------------------# # # Function skew # # Input: # img: loaded image # direction: vertical or horizontal # angle: -89 to 89 degrees # # Output: # new_img: skewed image # print \u201cWrong input!!!\u201d if inputs are not in range # #----------------------------------------------------------# def skew(img, direction, angle): #implement here direction = input(\"vertical or horizontal\") angle = input(int(\"angle\")) if 89 < angle or angle < -89: print(\"Wrong input!!!\") if direction == horizontal: if angle >= 0: convert(img, angle) else: convert(img, angle) if direction == vertical: if angle < 0: convert(img, angle) else: convert(img, angle) # img.show() img = load_picture( \"gurumi.png\" ) # w,h = img.size() # img.show() img_new = convert(img, 30) img_new.show()",
        "question": "Then, should I create a function for both vertical positive/negative numbers and horizontal positive/negative numbers?",
        "questionType": "task",
        "answer": "Whether it is a function or an if statement, you have to write four cases."
    },
    {
        "code": "f=open(\"average-latitude-longitude-countries.csv\",\"r\") c=f.readlines() country={} list1=[] list2=[] for i in range(1,len(c)): index=c[i].split(\"\\\"\") list1.append((index[1],index[3])) cord=c[i].split(\",\") a=float(cord[-2]) b=float(cord[-1].strip()) list2.append((index[1],(a,b))) country[index[1]]=[index[3],a,b]#{\uad6d\uac00\ucf54\ub4dc:[\uad6d\uac00\uba85,latitude,longitude]} print(list1) print(list2) for i in country.keys(): if country[i][-1]<=0: print(country[i][0]) code=input(\"Enter country code: \") print(country[code][0]) f.close()",
        "question": "I fixed the first error, but I'm not sure where the second error came from.There seems to be no missing country names in the list of tuples with country names. Can you give me a hint where the problem occurred?",
        "questionType": "error",
        "answer": "If the list1 and 2 printed earlier are correct, it seems that only line17 can cause problems."
    },
    {
        "code": "from cs1graphics import * from time import sleep def draw_animal(): # Implement this function. aurelion_sol = Layer() body = Rectangle(18, 4, Point(430, 110)) body.setFillColor('skyBlue') aurelion_sol.add(body) orbits = Layer orbit1 = Circle(3, Point(430, 130)) orbit2 = Circle(3, Point(430, 90)) orbit3 = Circle(3, Point(450, 110)) orbit4 = Circle(3, Point(410, 110)) orbit1.setFillColor('white') orbit2.setFillColor('white') orbit3.setFillColor('white') orbit4.setFillColor('white') def show_animation(): # Implement this function. paper = Canvas() paper.setBackgroundColor('black') paper.setWidth(500) paper.setHeight(300) paper.setTitle('Space') sun = Circle(18, Point(430, 220)) sun.setFillColor('yellow') sun.setDepth(40) Space.add(sun) flare = Circle(24, Point(430, 220)) flare.setFillColor('red') flare.setDepth(30) Space.add(flare) draw_animal() show_animation()",
        "question": "Is it possible to include other layers in a layer?",
        "questionType": "usage",
        "answer": "You can have as many sub layers as you need"
    },
    {
        "code": "import math #--------------------------------------------------------------# # # Function dec_to_any # # Input: # n: number to convert # radix: radix to use # # Output: # new_num: converted number # #--------------------------------------------------------------# def dec_to_any_list(n,radix): l1 = [] count = 1 num = n while n > radix: n // radix n = n//radix count = count + 1 for i in range (count): r = int(num%radix) l1.append(r) num = num//radix if l1[-1] ==0: l1.append(1) l1.reverse() for i in range (len(l1)): if l1[i] == 10: l1[i] = str('A') elif l1[i] == 11: l1[i] = str('B') elif l1[i] == 12: l1[i] = str('C') elif l1[i] == 13: l1[i] = str('D') elif l1[i] == 14: l1[i] = str('E') elif l1[i] == 15: l1[i] = str('F') for i in range (len(l1)): l1[i] = str(l1[i]) s = \"\".join(l1) new_num = s return new_num; def dec_to_any_string(n,radix): connum = \"\" count = 1 num = n while n > radix: n // radix n = n//radix count = count + 1 r = int(num%radix) r = str(r) connum = connum.replace('', r ) connum.split() num = num//radix r = int(num%radix) r = str(r) connum = connum.replace('', r ) print(connum) dec_to_any_string(40,5) #--------------------------------------------------------------# # # Function main # # This is the driver function # Do commandline input/output and formatting here # # Example: # Enter a number: 61 # Enter a radix: 16 # 61 in base 10 is 3D in base 16 # # # Just digits, no gap or another character # 123 (O) \u20181\u2019 \u20182\u2019 \u20183\u2019 (x) # \u201cWrong input!!!\u201d if inputs are not in range # You must use the formatting operator % (TAs will check!!!) #--------------------------------------------------------------# def main(): a = int(input('Enter a number: ')) b = int(input('Enter a radix: ')) if b>16 or b<2: print('Wrong input!!!') else: c = dec_to_any_list(a,b) print(a, \"in base 10 is\", c, \"in base\", b) #main()",
        "question": "When using a string, adding numbers to the string is not good.\nCurrently, the string appears as '303'. How do I make it '3', '0'?\nI tried to separate the single string, but when I think about it, I think I just need to remove the end of '303'",
        "questionType": "logical",
        "answer": "str is also a + operation\na = \"abc\"\na += \"def\"\nWhen run, a becomes \"abcdef\"!"
    },
    {
        "code": "import random from cs1graphics import * img_path = './images/' suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] face_names = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'] value = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10] bj_board = Canvas(600, 400, 'dark green', 'Black Jack 101') \"\"\" Define the Card class \"\"\" class Card: \"cards to play the blackjack\" def __init__(self,suit,face): self.suit=suit self.face=face self.img=str(self.suit)+\"_\"+str(self.face)+img_path if self.suit == 'Ace': self.value=11 elif self.face.isdigit(): self.value=int(self.face) else: self.value=10 self.state=True def create_deck(number = 1): \"\"\" Create a list(\"deck\") of all 52 cards, shuffle them and return the list. The list 'deck' have to include Card objects A Card is represented by a object with four attributes: the face, the suit, value, state, and the image object First, Have to define class 'Card' \"\"\" decked= [] for i in range(len(suit_names)): for j in range(len(face_names)): card=Card(suit_names[i],face_names[j]) decked.append(card) random.shuffle(decked) return decked def hand_value(hand): \"\"\" hand is a list including card objects Compute the value of the cards in the list \"hand\" \"\"\" Q=0 for i in range(len(hand)): Q=Q+hand[i].value return Q def card_string(card): \"\"\" Parameter \"card\" is a Card object Return a nice string to represent a card (sucn as \"a King of Spades\" or \"an Ace of Diamonds\") \"\"\" article=\"a \" if card.face in [\"8\",\"Ace\"]: article=\"an \" return (article + str(card.face)+\" of \"+card.suit) def ask_yesno(prompt): \"\"\" Display the text prompt and let's the user enter a string. If the user enters \"y\", the function returns \"True\", and if the user enters \"n\", the function returns \"False\". If the user enters anything else, the function prints \"I beg your pardon!\", and asks again, repreting this until the user has entered a correct string. \"\"\" while not prompt == \"y\" and not prompt == \"n\": print(\"I beg you pardon!\") else: if prompt == \"y\": return True elif prompt == \"n\": return False def draw_card(dealer,player): \"\"\" This funuction add the cards of dealer and player to canvas, bj_board. If the state of each Card object is false, then you have to show the hidden card image(Back.png). The dealer's first card is hidden state. The parameter dealer and player are List objects including Card Objects. The start position of dealer's card is (100,100). The start position of player's card is (100,300). You can use the following methods for positioning images and text: Image() Object, Text() Object, moveTo() method, setDepth() method. You should use help function - help('cs1graphics.Image') -> about Image(), moveTo(), setDepth() help('cs1graphics.Text') -> about Text(),moveTo(), setDepth() \"\"\" depth = 100 x0,y0 = 100,100 x1,y1 = 100,300 bj_board.clear() if len(dealer) >=1: for i in range(len(dealer)): if dealer[i].state==False: img=Image('Back./images/.png') img.moveTo(x0+(30*i),y0) bj_board.add(img) else: img=Image(dealer[i].img) img.moveTo(x0+(30*i),y0) bj_board.add(img) if len(player) >= 1: for j in range(len(player)): img=Image(player[i].img) img.moveTo(x1+(30*i),y0) bj_board.add(img) def main(): deck = [] while True: # prompt for starting a new game and create a deck print (\"Welcome to Black Jack 101!\\n\") if len(deck) < 12: deck = create_deck() # create two hands of dealer and player dealer = [] player = [] # initial two dealings card = deck.pop() print (\"You are dealt \" + card_string(card)) player.append(card) card = deck.pop() print (\"Dealer is dealt a hidden card\") card.state=False dealer.append(card) card = deck.pop() print (\"You are dealt \" + card_string(card)) player.append(card) card = deck.pop() print (\"Dealer is dealt \" + card_string(card)) dealer.append(card) print (\"Your total is\", hand_value(player)) draw_card(dealer,player) # player's turn to draw cards while hand_value(player) < 21 and ask_yesno(\"Would you like another card? (y/n) \"): # draw a card for the player card = deck.pop() print (\"You are dealt \" + card_string(card)) player.append(card) print (\"Your total is\", hand_value(player)) draw_card(dealer,player) # if the player's score is over 21, the player loses immediately. if hand_value(player) > 21: print (\"You went over 21! You lost.\") dealer[0].state = True draw_card(dealer,player) else: # draw cards for the dealer while the dealer's score is less than 17 print (\"\\nThe dealer's hidden card was \" + card_string(dealer[0])) while hand_value(dealer) < 17: card = deck.pop() print (\"Dealer is dealt \" + card_string(card)) dealer.append(card) print (\"The dealer's total is\", hand_value(dealer)) dealer[0].state = True draw_card(dealer,player) # summary player_total = hand_value(player) dealer_total = hand_value(dealer) print (\"\\nYour total is\", player_total) print (\"The dealer's total is\", dealer_total) if dealer_total > 21: print (\"The dealer went over 21! You win!\") else: if player_total > dealer_total: print (\"You win!\") elif player_total < dealer_total: print (\"You lost!\") else: print (\"You have a tie!\") if not ask_yesno(\"\\nPlay another round? (y/n) \"): bj_board.close() break main() help('cs1graphics.Image')",
        "question": "When I draw card, I want to write the image file name so that the image comes out.However, I am not sure how to write the file name of the image.",
        "questionType": "algorithm",
        "answer": "If you look at the images folder at the top left, you can see the names of the card images.\nClubs + ~~~\nYou can call it in combination"
    },
    {
        "code": "from cs1robots import * create_world() hubo = Robot(beepers=10) hubo.set_trace('blue') hubo.turn_left() def hubo.nine(): for i hubo. move()",
        "question": "I want to use the for statement, but I keep getting an error.\nI don't know what's wrong with def",
        "questionType": "error",
        "answer": "Function names cannot contain \".\".\nI understand the intention to use the function with hubo.nine(), but please define it as def nine() and use it as nine() instead of hubo.nine().\nThe reason is that functions like hubo.move() are already defined internally when creating a hubo robot."
    },
    {
        "code": "from cs1robots import * def turn_left(): global dx, dy dx, dy = -dy, dx my_robot.turn_left() def turn_right(): for i in range(3): turn_left() def move_further() : global x, y x += dx y += dy my_robot.move() def go_back() : for i in range(2) : turn_left() move_further() my_robot.drop_beeper() turn_right() move_further() load_world('worlds/rain2.wld') # load_world('worlds/rain2.wld') my_robot = Robot(beepers=100, avenue=2, street=6, orientation='E') my_robot.set_pause(0.1) my_robot.set_trace(\"blue\") x, y, dx, dy = 2, 6, 1, 0 counter = 0 move_further() initial_pos = (x,y) turn_right() move_further() while not (x, y) == initial_pos : if my_robot.right_is_clear() and my_robot.left_is_clear() : counter += 1 else : counter = 0 if counter == 2 : counter = 0 go_back() if my_robot.right_is_clear() : turn_right() move_further() elif my_robot.front_is_clear() : move_further() else : turn_left() move_further()",
        "question": "In task4, can you explain how do you check blanks are window or corner?",
        "questionType": "code_explain",
        "answer": "Okay, so I mainly try to go right if it is possible. And then there are two cases: 1) window 2) corner if it is a window then when I turn right and go forward, left and right of the robot must still be empty. If it is a corner, the right of the robot must not be empty. The variable counter keeps this information for me. When I decide that the robot is outside (went out from a window) I backtrack it and place a beeper on the window."
    },
    {
        "code": "from cs1robots import * # Your code must work for both of the worlds below. load_world('worlds/rain1.wld') #load_world('worlds/rain2.wld') # Initialize your robot at the door of the house. hubo = Robot(beepers=100, avenue=2, street=6, orientation='E') hubo.set_trace('blue') def turn_right(): hubo.turn_left() hubo.turn_left() hubo.turn_left() def go(): while hubo.front_is_clear(): hubo.move() def go_close(): while hubo.front_is_clear(): if hubo.left_is_clear(): hubo.drop_beeper() hubo.move() hubo.move() hubo.turn_left() go() for i in range(3): turn_right() go_close() turn_right() hubo.move() if hubo.left_is_clear(): hubo.turn_left() hubo.move() go_close() turn_right() hubo.move() hubo.move()",
        "question": "How do you usually distinguish between a window and a corner in task4?",
        "questionType": "algorithm",
        "answer": "When turning counterclockwise\nIf the right side is empty, take a step toward it and distinguish whether it is a window or a broken section\nRemember that and come back\nThere is a way to separate cases\nOr when the right side is empty, just go ahead one more step\nThere is also a way to distinguish whether it was a window or a bent part by whether it met the wall or not."
    }
]